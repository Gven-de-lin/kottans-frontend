## Git Bash

Продовжую своє знайомство з git, лекційний матеріал та тестові завдання на coursera це дійсно крута ідея. Маю великі надії на цей курс, далі більше.

diff - show changes between commits, commit and working tree, etc

git clone - clone a repository into a new directory

git init - create an empty Git repository or reinitialize an existing one

git add - add file contents to the index

git commit - record changes to the repository

git push - update remote refs along with associated objects

git status - show the working tree status

git log - show commit logs

git config - get and set repository or global options

git commit -a - Stages files automatically

git show - Shows various objects

git diff --staged - An alias to --cached, this will show all staged files compared to the named commit

git add -p - Allows a user to interactively review patches to add to the current commit

git mv - Similar to the Linux `mv` command, this moves a file

git rm - Similar to the Linux `rm` command, this deletes, or removes a file

## Linux CLI, and HTTP
Знайомство з  Command line Linux пройшло успішно. З Command line Linux раніше не працювала, тому більшість команд нові, але дуже схожі схожі на команди з Git Bash.(можливо це одней й те саме, але з різним інтерфейсом?) Фундаментальні знання, які допомагають працювати з проектом. Цей факт було перевірено під час створення особистого навчального проекта "NFTHERO". Він ще в процесі, тому команди використовую щоб запушити зміни.
Впевненна що ці знання допоможуть мені у найближчему майбутньому.

![image](https://user-images.githubusercontent.com/105444704/180610875-6b1869d4-4a48-4803-ad17-8138d9fc965f.png)
![image](https://user-images.githubusercontent.com/105444704/180610930-f24cf2ac-210b-4db6-a7b9-77dbac914047.png)
![image](https://user-images.githubusercontent.com/105444704/180610967-e72483eb-cccc-4069-b995-20fe50dddd91.png)
![image](https://user-images.githubusercontent.com/105444704/180611029-2402406e-9da6-45d9-9ac1-e71074e2fd97.png)


Розміщення пустого рядка між заголовками та тілом повідомлення є обов'язковим. У повідомленні може міститися один або декілька заголовків, серед котрих умовно (\* згідно з контекстом) можна виділити:

Стосовно HTTP:
1. Що було новим
    - протокол HTTP вважається протоколом без запам'ятовування стану
    - TCP/IP гарантує доставку переданих пакетів даних у потрібній послідовності, але трафік у цьому разі  може бути дуже нерівномірний, тому що пакети зазнають             усіляких затримок), проте може використовуватися будь-який інший придатний для транспортування повідомлень механізм (* наприклад, QUIC (Quick UDP Internet             Connections) –  експериментальний інтернет-протокол, розроблений Google в кінці 2012 року)
    - HTTP/1.1 тривалі з'єднання (* persistent connections; передавання в одному TCP-з'єднанні декількох об'єктів), кодування передавання даних типу  "chunked" (*           частинами) (* chunked transfer-coding; механізм передавання даних у протоколі передавання гіпертексту (HTTP), що дозволяє надійно доставляти дані від сервера           клієнту без необхідності знати точний розмір усього тіла HTTP-повідомлення заздалегідь.
    - У специфікації HTTP визначається наступна загальна структура повідомлень запиту та відповіді:
      message = <start-line>
          *(<message-header>)
          CRLF
          [<message-body>]
 
<start-line> = Request-Line | Status-Line 
<message-header> = Field-Name ':' Field-Value

загальні заголовки (general headers; застосовні для повідомлень і запиту, і відповіді).
заголовки запиту.
заголовки відповіді.
заголовки тіла об'єкта (entity headers).
У тілі повідомлення можуть міститися всі дані повідомлення або воно може бути поділено на частини, якщо використовується кодування передачі типу «chunked» (Transfer-Encoding: chunked). Усім клієнтам HTTP/1.1 необхідно, щоб у повідомленні був заголовок Transfer-Encoding.

Загальні заголовки
Є декілька заголовків, що використовуються і в повідомленнях запиту, і в повідомленнях відповіді:

general-header = Cache-Control  
 | Connection  
 | Date  
 | Pragma  
 | Trailer  
 | Transfer-Encoding
| Upgrade  
 | Via  
 | Warning
Ми вже знайомі з деякими з цих заголовків (Via і Transfer-Encoding). Ми розглянемо Cache-Control і Connection у другій частині.

- Заголовок Via використовується у повідомленнях, що передаються за методом TRACE, і оновлюється всіма проміжними проксі та шлюзами.
- Заголовок Pragma вважається спеціалізованим заголовком і може бути використаний для додавання до повідомлення пов'язаних із конкретною реалізацією додатка заголовків. Найчастіше використовується директива Pragma: no-cache, що є еквівалентом Cache-Control: no-cache версії HTTP/1.1. Цей заголовок буде розглянуто у другій частині посібника.
- Заголовок Date використовується для додавання часу створення повідомлення запиту/відповіді.
- Upgrade використовується для переключення протоколів і дозволяє здійснювати плавний перехід на використання нового протоколу.
- Transfer-Encoding звичайно використовується для поділення відповіді на менші частини за допомогою директиви Transfer-Encoding: chunked.Цей заголовок вперше з'явився у версії HTTP/1.1; дозволяє реалізувати потокову передачу даних відповіді клієнту (\* переміщення даних частинами) (на відміну від пересилання копії даних повністю).

Заголовки тіла повідомлення

У повідомленнях запиту та відповіді можуть використовуватися заголовки для тіла об'єкта, щоб передати метаінформацію про вміст повідомлення (тіло повідомлення/об'єкта). До цього типу заголовків належать:

entity-header = Allow  
 | Content-Encoding  
 | Content-Language  
 | Content-Length  
 | Content-Location  
 | Content-MD5  
 | Content-Range  
 | Content-Type  
 | Expires  
 | Last-Modified
За допомогою всіх заголовків із префіксом Content- передається інформація про структуру, кодування та розмір тіла повідомлення. Деякі із цих заголовків повинні бути, якщо у повідомленні є вміст.

Завдяки заголовку Expires задається термін, по закінченні якого тіло повідомлення вважається застарілим. Цікаво, що при вказанні значення "never expires" цей термін дорівнює одному року. За допомогою заголовка Last-Modified вказується час останньої модифікації файлу.

Формат повідомлень запиту

Загальна структура повідомлень запиту така ж, як і вище, проте рядок запиту виглядає наступним чином:

Request-Line = Method SP URI SP HTTP-Version CRLF
Method = "OPTIONS"
| "HEAD"  
 | "GET"  
 | "POST"  
 | "PUT"  
 | "DELETE"  
 | "TRACE"

SP – просторовий роздільник між лексемами. На місті HTTP-Version вказується "HTTP/1.1", і потім йде перехід на новий рядок. Таким чином, типове повідомлення запиту може виглядати наступним чином:

GET /articles/http-basics HTTP/1.1
Host: www.articles.com
Connection: keep-alive
Cache-Control: no-cache
Pragma: no-cache
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,_/_;q=0.8

заголовок Host є обов'язковим для клієнтів, що працюють за HTTP/1.1. Запити, виконувані за методом GET, не мають тіла об'єкта, а запити, виконувані за методом POST, можуть містити дані в тілі повідомлення для створення ресурсу.

Заголовки запиту грають роль модифікаторів повідомлення запиту. Повний список наявних заголовків запиту не дуже довгий, його наведено нижче: Заголовки, що не входять до списку, розглядаються як поля заголовка об'єкта.

request-header = Accept  
 | Accept-Charset  
 | Accept-Encoding  
 | Accept-Language  
 | Authorization  
 | Expect  
 | From  
 | Host  
 | If-Match  
 | If-Modified-Since
| If-None-Match  
 | If-Range  
 | If-Unmodified-Since
| Max-Forwards  
 | Proxy-Authorization
| Range  
 | Referer  
 | TE  
 | User-Agent

В заголовках з префіксом Accept вказуються допустимі для прийому клієнтом форми інформації, мова та набір символів. У From, Host, Referer і User-Agent вказуються деталі про клієнта, що відправив запит. Заголовки з префіксом If- використовуються для надання запиту гнучкості, і сервер надсилає відповідь тільки тоді, коли задана умова виконується. В іншому випадку надсилається відповідь 304 Not Modified. Умову може бути задано на основі мітки часу або ETag.

Формат повідомлень відповіді

Формат повідомлень відповіді схожий з таким повідомлень запиту, за винятком стартового рядка та заголовків. Стартовий рядок має наступну структуру:

1Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF

На місті HTTP-Version вказується "HTTP/1.1".
Status-Code – один із раніше розглядуваних кодів стану.
Reason-Phrase – зрозуміла для людини версія (\* пояснююча фраза) коду стану.

Кількість заголовків відповіді також доволі обмежена; повний набір наведено нижче:

response-header = Accept-Ranges
| Age
| ETag  
 | Location  
 | Proxy-Authenticate
| Retry-After  
 | Server  
 | Vary  
 | WWW-Authenticate

У Age вказується час у секундах, коли повідомлення було згенеровано на сервері.
Значення ETag – хеш-значення об'єкта, отримане за допомогою алгоритму шифрування MD5 (\* Message Digest 5); використовується для перевірки наявності змін ресурсу.
Location використовується для інструктування клієнта про переадресацію та містить нову URL-адресу.
У Server вказується сервер, що надіслав повідомлення.

ExpressJS

ExpressJS як раз надає для цього простий API. Ми не будемо розглядати деталі API. Замість цього я дам вам посилання на детальну документацію з ExpressJS. Імена методів API у більшості випадків говорять самі за себе. Деякі приклади методів API, пов'язаних з обробленням запитів, наведено нижче:

req.body: для отримання тіла запиту.
req.query: для отримання фрагмента запиту URL.
req.originalUrl
req.host: для прочитання поля Host заголовка.
req.accepts: для отримання допустимих на стороні клієнта типів MIME (\* багатоцільові розширення пошти (поштової служби) в Інтернеті; стандарт на кодування в одному повідомленні текстової і нетекстової інформації (наприклад, графіки) для передавання електронною поштою в Інтернеті).
req.get або req.header: для прочитання будь-якого поля заголовка, переданого у вигляді аргументу.

Для формування відповіді клієнтові ExpressJS надає наступний API:

res.status: для явного вказання коду стану.
res.set: для вказання певного заголовка.
res.send: для відправлення HTML, JSON або послідовності октетів.
res.sendFile: для передачі файлу клієнтові.
res.render: для виконання шаблону представлення Express.
res.redirect: для переадресації до іншого маршруту. Express автоматично додає код за налаштуванням про переадресацію 302.

Ruby on Rails

У Rails модулі ActionController та ActionDispatch надають API для оброблення повідомлень запиту та відповіді.

ActionController надає високорівневий API для отримання URL-запиту, обробки результату та переадресації до іншого маршруту. Кінцева точка (маршрут) використовується для виконання вказаного у ньому методу (дії) (_ наприклад, якщо користувач переходить за /clients/new у вашому застосунку для додавання нового клієнта, Rails створює зразок ClientsController та викликає його метод new). Більшість необхідної контекстної (_ пов'язаної з конкретним запитом) інформації всередині методу стає доступною завдяки об'єктам request, response та params.

params: надає доступ до параметрів URL та даних, переданих за методом POST.
request: містить інформацію про клієнта, заголовки та URL.
response: використовується для встановлення значень заголовків та кодів стану.
render: для виконання шаблонів.
redirect_to: використовується для переадресації до іншого методу або на інший URL.

ActionDispatch надає тонко гранульований доступ до повідомлень запиту/відповіді за допомогою класів ActionDispatch::Request та ActionDispatch::Response. Цей модуль надає набір методів для перевірки типу запиту (get?(), post?(), head?(), local?()). Заголовки запиту можна напряму отримати за допомогою методу request.headers() .

Для роботи з відповіддю модуль надає методи cookies(), location=() та status=(). Якщо ви хочете поекспериментувати, то можете також задати тіло відповіді вручну за допомогою body=().

AJAX (\* Asynchronous JavaScript And XML – асинхронний JavaScript + XML) jQuery

Оскільки jQuery – перед усім, бібліотека для клієнтської частини додатка, то API AJAX надає можливості, протилежні тим, що реалізуються на стороні сервера. Іншими словами, завдяки їй ви можете прочитувати та змінювати повідомлення запиту. jQuery надає доступ до простого API за допомогою jQuery.ajax(settings):

Передаючи об'єкт із налаштуваннями, до складу якого входить функція зворотного виклику beforeSend, ми можемо змінювати заголовки запиту. До неї передається об'єкт jqXHR (jQuery XMLHttpRequest), що має метод (setRequestHeader()) для встановлення значень заголовків.

$.ajax({
url: 'http://www.articles.com/latest',
type: 'GET',
beforeSend: function (jqXHR) {
jqXHR.setRequestHeader('Accepts-Language', 'en-US,en');
}
});

Об'єкт jqXHR також може бути використаний для прочитання заголовків відповіді за допомогою методу jqXHR.getResponseHeader().
Якщо ви хочете виконувати певні дії при надходженні різних кодів стану, то ви можете вказати функцію зворотного виклику в об'єкті statusCode.

$.ajax({
statusCode: {
404: function() {
alert("page not found");
}
}
});

З'єднання HTTP

З'єднання HTTP ідентифікується на основі <source-IP, source-port> та <destination-IP, destination-port> (\* сокет (поєднання IP-адреси і номера порту) – інтерфейс між прикладним та транспортним рівнем хоста, тобто API між застосуванням та комп'ютерною мережею). На стороні клієнта застосування, що використовує HTTP, розпізнається за допомогою набору <IP, port>. Встановлення з'єднання між двома кінцевими вузлами локальної мережі (ЛМ) – процес, що складається з декількох етапів:

- встановлення відповідності імені хоста IP-адресі за допомогою DNS (\* Domain Name Server – сервер, що виконує перетворення імен доменів у IP-адреси; інтернет-служба, яка становить розподілену по всій земній кулі БД для ієрархічної системи імен мереж і комп'ютерів, підключених до Мережі, а також спосіб [протокол прикладного рівня] перетворення рядкових адресів інтернет-серверів у числові IP-адреси. Визначена в RFC 1034 і 1035. Протокол DNS працює над протоколом UDP і йому призначено порт за номером 35. DNS також часто використовують для розподілення навантаження між серверами ("дзеркалами"), що дублюють популярні сайти і поштові сервери).
- встановлення з’ єднатися з сервером
- відправлення запиту
- очікування відповіді
- закриття з'єднання

Для зменшення кількості мережевих затримок в HTTP/1.1 було введено постійні з'єднання – довготривалі з'єднання, що залишаються відкритими, доки клієнт їх не закриє. В HTTP/1.1 за налаштуванням застосовуються постійні з'єднання, і при встановленні з'єднання для виконання однієї транзакції клієнт повинен додати заголовок запиту Connection: close. Це повідомляє серверу, що з'єднання необхідно закрити після відправлення відповіді.

Окрім постійних з'єднань браузери/клієнти також використовують технологію – паралельні з'єднання – для мінімізації кількості мережевих затримок. Згідно з цією давно існуючою концепцією створюється набір із декількох з'єднань (звичайно максимум – шість з'єднань). Якщо клієнту необхідно завантажити шість ресурсів з веб-сайту, то клієнт виконує шість паралельних з'єднань для їх завантаження, завдяки чому підвищується швидкість обслуговування користувачів сервером. Ця технологія – значний ривок уперед у порівнянні з послідовними з'єднаннями, при котрих клієнт завантажує ресурс тільки після отримання попереднього об'єкта.

Реалізація з'єднання на стороні сервера

Сервер звичайно прослуховує з'єднання та отримує запити на обслуговування. Виконувані ним дії включають:

- відкриття каналу для початку прослуховування 80 порту (або якого-небудь іншого)
- отримання та розбір повідомлення
- формування відповіді
- додавання заголовків відповіді
- відправлення відповіді клієнтові
- закриття з'єднання за наявності заголовка запиту Connection: close

Вище наведено, звісно ж, на вичерпний список виконуваних сервером дій. Більшості додатків необхідно знати, хто відправляє запит, щоб підігнати відповіді під конкретного користувача. Саме тут у гру вступають ідентифікація та автентифікація.

Ідентифікація та автентифікація

Задача ідентифікації полягає в тому, щоб пристосувати відповідь під конкретного користувача; зрозуміло, що для цього сервер повинен володіти інформацією про користувача.

Для її збору є декілька способів, і більшість веб-сайтів використовують їх комбінацію:

- Заголовки запиту: From, Referer, User-Agent - ми розглядали їх в Частині 1.
- ІР-адреса клієнта
- Fat Urls (_ збагачене посилання; також називають "extended link" – розширене посилання) – стан (_ інформація про сесію поточного користувача) зберігається завдяки зміні URL-адрес (_ динамічно сервером) та переадресації його по мірі переглядання сайту за іншою адресою (_ іншою, ніж було задано первісно, наприклад, сервер надсилає документ з ... <a href="/exec/obidos/tg/browse/-/229220/ref=gr_gifts/002-1145265-8016838">All Gifts</a><br> ... , де до кожної URL-адреси додається суфікс «002-1145265-8016838»); по суті стан акумулюється при кожному переході користувача за URL-адресою.
- Кукі (_ підтримуваний протоко­лом HTTP текстовий запис розміром до 4 Кбайт із даними про користувача, що повертає веб-сервер під час реєстрації користувача, який зберігається на його ПК) – найбільш популярний та ненав'язливий підхід (_ із перелічених тут, оскільки тільки при ньому від користувача необхідно отримати попередню згоду на використання кукі-файлів; проте самі кукі можна поділити на категорії в залежності від їх нав'язливості (ступінь посягання на персональну інформацію): від нульового до високого ступеня (докладніше тут https://www.cookielaw.org/blog/2012/2/16/how-intrusive-are-your-cookies.aspx)).
  Завдяки кукі сервер може додати до відповідей довільну інформацію за допомогою заголовка відповіді Set-Cookie. Значення кукі задаються у формі пар name=value (\* им'я=значення), відокремлених символом «;», наприклад: Set-Cookie: session-id=12345ABC; username=nettuts.

Сервер може також обмежити використання кукі тільки для певного домену або шляху, а також він може зробити їх постійними (\* об'єкт, що пересилається по мережі, час дії якого не обмежується часом виконання програм, що його створили та використовують) за допомогою встановлення значення для заголовка Expires. Кукі автоматично відправляються браузером при кожному запиті до сервера; також браузер гарантує, що до запиту додаються тільки специфічні для певного домену або шляху кукі. Для відправлення цих кукі на сервер використовується заголовок запиту Cookie: name=value [; name2=value2].

Найкращий спосіб ідентифікації користувача – зобов'язати його реєструватися (sign up) або входити до додатка (log in), проте для реалізації цієї можливості необхідно докласти зусилля як розробникові, так і користувачеві.

Автентифікація

У самому протоколі HTTP реалізована підтримка елементарної форми автентифікації – Basic Authentication, а також більш захищеної – Digest Authentication.

При Basic Authentication сервер спочатку відхиляє запит клієнта та відправляє відповідь із заголовком відповіді WWW-Authenticate та кодом стану 401 Unauthorized (_ і відповідною фразою). Отримавши цей заголовок, браузер відображує діалог для входу на сайт, запитуючи пароль та ім'я користувача. Ця інформація відсилається у закодованому за допомогою коду Base-64 (_ спосіб кодування електронної пошти, сумісний із МІМЕ, стандартизований у RFC 2045. Використовує для перетворення тексту на шестибітовий код (значення від 0 до 63) спеціальну таблицю) форматі у заголовку запиту Authentication. Після цього сервер перевіряє правильність даних у запиті та надає доступ у разі коректності даних. Деякі сервери також можуть надсилати заголовок Authentication-Info із додатковою інформацією про автентифікацію.

Логічно виведений із Basic-Authentication спосіб автентифікації – Proxy Authentication. У цьому випадку запит на автентифікацію відправляється не сервером, а проміжним проксі. Проксі-сервер відправляє заголовок Proxy-Authenticate з кодом стану 407 Unauthorized (\* і відповідною фразою). У відповідь клієнт повинен відіслати пароль та ім'я користувача в заголовку запиту Proxy-Authorization.

КЕШУВАННЯ

Робота з кешем відбувається на декількох рівнях мережевої інфраструктури: починаючи від браузера та закінчуючи первісним сервером. В залежності від того, де міститься кеш, можна виділити наступні його категорії:

- Приватний: усередині браузера; тут гешуються паролі, імена користувачів, URL-адреси, історія відвідування та веб-контент. Цей тип кеш-пам'яті звичайно невеликого об'єму та призначений для одного користувача.
- Публічний: розміщується на проксі для гешування між сервером та клієнтом. Об'єм пам'яті цього типу кеш-пам'яті набагато більше, оскільки тут обслуговуються багато користувачів. Згідно з усталеною практикою (\* загальноприйнята практика, що не є правилом) між клієнтом та первісним сервером слід розміщувати багато проксі-серверів для гешування. Завдяки цьому полегшується обслуговування контенту, до якого часто звертаються, і водночас зберігається можливість отримати контент, який рідко запитують.

Підтримування кеш-пам'яті

Незалежно від того, де розташовується кеш, процес підтримування кеш-пам'яті доволі подібний:

- Отримання повідомлення запиту.
- Розбір URL-адреси та заголовків.
- Пошук локальної копії; у випадку відсутності отримати ресурс та зберегти локально.
- Перевірка актуальності контенту в кеш-пам'яті; виконати запит для оновлення контенту тільки у разі потреби.
- Формування відповіді з тіла повідомлення з кеш-пам'яті та оновлених заголовків.
- Відправлення відповіді клієнту.
- Фіксування події в журналі реєстрації подій (Необов'язково)

Контроль можливості Кешування

Термін дії документа повинен визначатися сервером, що відправляє документ. У разі новосного веб-сайту термін головної сторінки повинен скінчатися по завершенні одного дня (або іноді навіть кожного часу!). HTTP надає заголовки відповіді Cache-Control і Expires для встановлення дати закінчення терміну документів. Як вже зазначалося раніше, Expires заснований на використанні абсолютних значень дати і не є надійним рішенням для контролювання кешу.

Заголовок Cache-Control значно корисніший, і у ньому можуть бути використані декілька різних значень для визначення способу гешування відповіді клієнтом:

- Cache-Control: no-cache: клієнту дозволено зберігати документ; проте він повинен звіряти актуальність контенту з сервером при кожному запиті. Є сумісний з HTTP/1.0
- заголовок – Pragma: no-cache, що працює таким же чином.
- Cache-Control: no-store: це більш сувора директива клієнту зовсім не зберігати документ.
- Cache-Control: must-revalidate: клієнт повинен пропустити визначення актуальності контенту та завжди виконувати повторну перевірку ресурсу на сервері. Не дозволяється використовувати відповідь із кеш-пам'яті у разі недоступності сервера.
- Cache-Control: max-age: тут задається відносний вік (у секундах) з моменту створення відповіді.

Якщо сервер не відправляє заголовок Cache-Control з яким-небудь значенням, то клієнт має право використовувати свій власний евристичний алгоритм (\* алгоритм оптимізації, що генерує припустиме, але не обов'язково оптимальне рішення) для визначення актуальності контенту.

Обмеження актуальності контенту з боку клієнта

Можливість гешування контенту визначається не тільки сервером. Клієнт також може брати у цьому участь. Завдяки цьому клієнт може накласти обмеження на відповідь. Ця можливість реалізується за допомогою того ж самого заголовка Cache-Control, хоча і з деякими іншими значеннями:

- Cache-Control: min-fresh=<s>: документ повинен бути дійсним як мінімум <s> секунд.
- Cache-Control: max-stale або Cache-Control: max-stale=<s>: документ не може бути відправлено із кеш-пам'яті, якщо він застарів більше, ніж на <s> секунд.
- Cache-Control: max-age=<s>: документ не може бути відправлено з кеш-пам'яті, якщо він знаходився там більше <s> секунд.
- Cache-Control: no-cache або Pragma: no-cache: клієнт не буде приймати ресурс із кешу до того часу, поки не буде виконано його перевірку на стороні сервера.

 Великий обсяг нової інформації🤯😰📚, яка на мою думку потрібна для розуміння роботи браузера та клієнт-серверної архітектури. Подальшому буде використовуватися скоріш за все як фундаментальні основи.
